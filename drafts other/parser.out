Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    if
    else
    break
    function
    then
    in
    repeat
    input
    include
    compile
    until
    to
    start
    end
    and
    or
    COMMA
    SEMI
    NEWLINE

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> error
Rule 3     statement -> variable eq expr
Rule 4     statement -> variable eq relexpr
Rule 5     statement -> variable eq
Rule 6     statement -> variable error expr
Rule 7     expr -> expr PLUS expr
Rule 8     expr -> expr MINUS expr
Rule 9     expr -> expr TIMES expr
Rule 10    expr -> expr DIVIDE expr
Rule 11    expr -> expr POWER expr
Rule 12    expr -> INTEGER
Rule 13    expr -> FLOAT
Rule 14    expr -> STRING
Rule 15    expr -> variable
Rule 16    expr -> LPAREN expr RPAREN
Rule 17    expr -> MINUS expr
Rule 18    relexpr -> expr lt expr
Rule 19    relexpr -> expr le expr
Rule 20    relexpr -> expr gt expr
Rule 21    relexpr -> expr ge expr
Rule 22    relexpr -> expr eq expr
Rule 23    relexpr -> expr ne expr
Rule 24    variable -> ID
Rule 25    print_statement -> print variable
Rule 26    print_statement -> print expr

Terminals, with rules where they appear

COMMA                : 
DIVIDE               : 10
FLOAT                : 13
ID                   : 24
INTEGER              : 12
LPAREN               : 16
MINUS                : 8 17
NEWLINE              : 
PLUS                 : 7
POWER                : 11
RPAREN               : 16
SEMI                 : 
STRING               : 14
TIMES                : 9
and                  : 
break                : 
compile              : 
else                 : 
end                  : 
eq                   : 3 4 5 22
error                : 2 6
function             : 
ge                   : 21
gt                   : 20
if                   : 
in                   : 
include              : 
input                : 
le                   : 19
lt                   : 18
ne                   : 23
or                   : 
print                : 25 26
repeat               : 
start                : 
then                 : 
to                   : 
until                : 

Nonterminals, with rules where they appear

expr                 : 3 6 7 7 8 8 9 9 10 10 11 11 16 17 18 18 19 19 20 20 21 21 22 22 23 23 26
print_statement      : 
program              : 0
relexpr              : 4
statement            : 1
variable             : 3 4 5 6 15 25

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . error
    (3) statement -> . variable eq expr
    (4) statement -> . variable eq relexpr
    (5) statement -> . variable eq
    (6) statement -> . variable error expr
    (24) variable -> . ID

    error           shift and go to state 3
    ID              shift and go to state 5

    program                        shift and go to state 1
    statement                      shift and go to state 2
    variable                       shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> error .

    $end            reduce using rule 2 (program -> error .)


state 4

    (3) statement -> variable . eq expr
    (4) statement -> variable . eq relexpr
    (5) statement -> variable . eq
    (6) statement -> variable . error expr

    eq              shift and go to state 6
    error           shift and go to state 7


state 5

    (24) variable -> ID .

    eq              reduce using rule 24 (variable -> ID .)
    error           reduce using rule 24 (variable -> ID .)
    PLUS            reduce using rule 24 (variable -> ID .)
    MINUS           reduce using rule 24 (variable -> ID .)
    TIMES           reduce using rule 24 (variable -> ID .)
    DIVIDE          reduce using rule 24 (variable -> ID .)
    POWER           reduce using rule 24 (variable -> ID .)
    lt              reduce using rule 24 (variable -> ID .)
    le              reduce using rule 24 (variable -> ID .)
    gt              reduce using rule 24 (variable -> ID .)
    ge              reduce using rule 24 (variable -> ID .)
    ne              reduce using rule 24 (variable -> ID .)
    $end            reduce using rule 24 (variable -> ID .)
    RPAREN          reduce using rule 24 (variable -> ID .)


state 6

    (3) statement -> variable eq . expr
    (4) statement -> variable eq . relexpr
    (5) statement -> variable eq .
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (18) relexpr -> . expr lt expr
    (19) relexpr -> . expr le expr
    (20) relexpr -> . expr gt expr
    (21) relexpr -> . expr ge expr
    (22) relexpr -> . expr eq expr
    (23) relexpr -> . expr ne expr
    (24) variable -> . ID

    $end            reduce using rule 5 (statement -> variable eq .)
    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    variable                       shift and go to state 8
    expr                           shift and go to state 9
    relexpr                        shift and go to state 10

state 7

    (6) statement -> variable error . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    variable                       shift and go to state 8
    expr                           shift and go to state 16

state 8

    (15) expr -> variable .

    PLUS            reduce using rule 15 (expr -> variable .)
    MINUS           reduce using rule 15 (expr -> variable .)
    TIMES           reduce using rule 15 (expr -> variable .)
    DIVIDE          reduce using rule 15 (expr -> variable .)
    POWER           reduce using rule 15 (expr -> variable .)
    lt              reduce using rule 15 (expr -> variable .)
    le              reduce using rule 15 (expr -> variable .)
    gt              reduce using rule 15 (expr -> variable .)
    ge              reduce using rule 15 (expr -> variable .)
    eq              reduce using rule 15 (expr -> variable .)
    ne              reduce using rule 15 (expr -> variable .)
    $end            reduce using rule 15 (expr -> variable .)
    RPAREN          reduce using rule 15 (expr -> variable .)


state 9

    (3) statement -> variable eq expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr
    (18) relexpr -> expr . lt expr
    (19) relexpr -> expr . le expr
    (20) relexpr -> expr . gt expr
    (21) relexpr -> expr . ge expr
    (22) relexpr -> expr . eq expr
    (23) relexpr -> expr . ne expr

    $end            reduce using rule 3 (statement -> variable eq expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22
    lt              shift and go to state 23
    le              shift and go to state 24
    gt              shift and go to state 25
    ge              shift and go to state 26
    eq              shift and go to state 17
    ne              shift and go to state 27


state 10

    (4) statement -> variable eq relexpr .

    $end            reduce using rule 4 (statement -> variable eq relexpr .)


state 11

    (17) expr -> MINUS . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 28
    variable                       shift and go to state 8

state 12

    (12) expr -> INTEGER .

    PLUS            reduce using rule 12 (expr -> INTEGER .)
    MINUS           reduce using rule 12 (expr -> INTEGER .)
    TIMES           reduce using rule 12 (expr -> INTEGER .)
    DIVIDE          reduce using rule 12 (expr -> INTEGER .)
    POWER           reduce using rule 12 (expr -> INTEGER .)
    lt              reduce using rule 12 (expr -> INTEGER .)
    le              reduce using rule 12 (expr -> INTEGER .)
    gt              reduce using rule 12 (expr -> INTEGER .)
    ge              reduce using rule 12 (expr -> INTEGER .)
    eq              reduce using rule 12 (expr -> INTEGER .)
    ne              reduce using rule 12 (expr -> INTEGER .)
    $end            reduce using rule 12 (expr -> INTEGER .)
    RPAREN          reduce using rule 12 (expr -> INTEGER .)


state 13

    (13) expr -> FLOAT .

    PLUS            reduce using rule 13 (expr -> FLOAT .)
    MINUS           reduce using rule 13 (expr -> FLOAT .)
    TIMES           reduce using rule 13 (expr -> FLOAT .)
    DIVIDE          reduce using rule 13 (expr -> FLOAT .)
    POWER           reduce using rule 13 (expr -> FLOAT .)
    lt              reduce using rule 13 (expr -> FLOAT .)
    le              reduce using rule 13 (expr -> FLOAT .)
    gt              reduce using rule 13 (expr -> FLOAT .)
    ge              reduce using rule 13 (expr -> FLOAT .)
    eq              reduce using rule 13 (expr -> FLOAT .)
    ne              reduce using rule 13 (expr -> FLOAT .)
    $end            reduce using rule 13 (expr -> FLOAT .)
    RPAREN          reduce using rule 13 (expr -> FLOAT .)


state 14

    (14) expr -> STRING .

    PLUS            reduce using rule 14 (expr -> STRING .)
    MINUS           reduce using rule 14 (expr -> STRING .)
    TIMES           reduce using rule 14 (expr -> STRING .)
    DIVIDE          reduce using rule 14 (expr -> STRING .)
    POWER           reduce using rule 14 (expr -> STRING .)
    lt              reduce using rule 14 (expr -> STRING .)
    le              reduce using rule 14 (expr -> STRING .)
    gt              reduce using rule 14 (expr -> STRING .)
    ge              reduce using rule 14 (expr -> STRING .)
    eq              reduce using rule 14 (expr -> STRING .)
    ne              reduce using rule 14 (expr -> STRING .)
    $end            reduce using rule 14 (expr -> STRING .)
    RPAREN          reduce using rule 14 (expr -> STRING .)


state 15

    (16) expr -> LPAREN . expr RPAREN
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 29
    variable                       shift and go to state 8

state 16

    (6) statement -> variable error expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 6 (statement -> variable error expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 17

    (22) relexpr -> expr eq . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 30
    variable                       shift and go to state 8

state 18

    (7) expr -> expr PLUS . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 31
    variable                       shift and go to state 8

state 19

    (8) expr -> expr MINUS . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 32
    variable                       shift and go to state 8

state 20

    (9) expr -> expr TIMES . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 33
    variable                       shift and go to state 8

state 21

    (10) expr -> expr DIVIDE . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 34
    variable                       shift and go to state 8

state 22

    (11) expr -> expr POWER . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 35
    variable                       shift and go to state 8

state 23

    (18) relexpr -> expr lt . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 36
    variable                       shift and go to state 8

state 24

    (19) relexpr -> expr le . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 37
    variable                       shift and go to state 8

state 25

    (20) relexpr -> expr gt . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 38
    variable                       shift and go to state 8

state 26

    (21) relexpr -> expr ge . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 39
    variable                       shift and go to state 8

state 27

    (23) relexpr -> expr ne . expr
    (7) expr -> . expr PLUS expr
    (8) expr -> . expr MINUS expr
    (9) expr -> . expr TIMES expr
    (10) expr -> . expr DIVIDE expr
    (11) expr -> . expr POWER expr
    (12) expr -> . INTEGER
    (13) expr -> . FLOAT
    (14) expr -> . STRING
    (15) expr -> . variable
    (16) expr -> . LPAREN expr RPAREN
    (17) expr -> . MINUS expr
    (24) variable -> . ID

    INTEGER         shift and go to state 12
    FLOAT           shift and go to state 13
    STRING          shift and go to state 14
    LPAREN          shift and go to state 15
    MINUS           shift and go to state 11
    ID              shift and go to state 5

    expr                           shift and go to state 40
    variable                       shift and go to state 8

state 28

    (17) expr -> MINUS expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 17 (expr -> MINUS expr .)
    MINUS           reduce using rule 17 (expr -> MINUS expr .)
    TIMES           reduce using rule 17 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 17 (expr -> MINUS expr .)
    POWER           reduce using rule 17 (expr -> MINUS expr .)
    lt              reduce using rule 17 (expr -> MINUS expr .)
    le              reduce using rule 17 (expr -> MINUS expr .)
    gt              reduce using rule 17 (expr -> MINUS expr .)
    ge              reduce using rule 17 (expr -> MINUS expr .)
    eq              reduce using rule 17 (expr -> MINUS expr .)
    ne              reduce using rule 17 (expr -> MINUS expr .)
    $end            reduce using rule 17 (expr -> MINUS expr .)
    RPAREN          reduce using rule 17 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]
  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! POWER           [ shift and go to state 22 ]


state 29

    (16) expr -> LPAREN expr . RPAREN
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    RPAREN          shift and go to state 41
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 30

    (22) relexpr -> expr eq expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 22 (relexpr -> expr eq expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 31

    (7) expr -> expr PLUS expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 7 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 7 (expr -> expr PLUS expr .)
    lt              reduce using rule 7 (expr -> expr PLUS expr .)
    le              reduce using rule 7 (expr -> expr PLUS expr .)
    gt              reduce using rule 7 (expr -> expr PLUS expr .)
    ge              reduce using rule 7 (expr -> expr PLUS expr .)
    eq              reduce using rule 7 (expr -> expr PLUS expr .)
    ne              reduce using rule 7 (expr -> expr PLUS expr .)
    $end            reduce using rule 7 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 7 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22

  ! TIMES           [ reduce using rule 7 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 7 (expr -> expr PLUS expr .) ]
  ! POWER           [ reduce using rule 7 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]


state 32

    (8) expr -> expr MINUS expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 8 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 8 (expr -> expr MINUS expr .)
    lt              reduce using rule 8 (expr -> expr MINUS expr .)
    le              reduce using rule 8 (expr -> expr MINUS expr .)
    gt              reduce using rule 8 (expr -> expr MINUS expr .)
    ge              reduce using rule 8 (expr -> expr MINUS expr .)
    eq              reduce using rule 8 (expr -> expr MINUS expr .)
    ne              reduce using rule 8 (expr -> expr MINUS expr .)
    $end            reduce using rule 8 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 8 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22

  ! TIMES           [ reduce using rule 8 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 8 (expr -> expr MINUS expr .) ]
  ! POWER           [ reduce using rule 8 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]


state 33

    (9) expr -> expr TIMES expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 9 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 9 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 9 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 9 (expr -> expr TIMES expr .)
    lt              reduce using rule 9 (expr -> expr TIMES expr .)
    le              reduce using rule 9 (expr -> expr TIMES expr .)
    gt              reduce using rule 9 (expr -> expr TIMES expr .)
    ge              reduce using rule 9 (expr -> expr TIMES expr .)
    eq              reduce using rule 9 (expr -> expr TIMES expr .)
    ne              reduce using rule 9 (expr -> expr TIMES expr .)
    $end            reduce using rule 9 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 9 (expr -> expr TIMES expr .)
    POWER           shift and go to state 22

  ! POWER           [ reduce using rule 9 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]
  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]


state 34

    (10) expr -> expr DIVIDE expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 10 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 10 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 10 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 10 (expr -> expr DIVIDE expr .)
    lt              reduce using rule 10 (expr -> expr DIVIDE expr .)
    le              reduce using rule 10 (expr -> expr DIVIDE expr .)
    gt              reduce using rule 10 (expr -> expr DIVIDE expr .)
    ge              reduce using rule 10 (expr -> expr DIVIDE expr .)
    eq              reduce using rule 10 (expr -> expr DIVIDE expr .)
    ne              reduce using rule 10 (expr -> expr DIVIDE expr .)
    $end            reduce using rule 10 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 10 (expr -> expr DIVIDE expr .)
    POWER           shift and go to state 22

  ! POWER           [ reduce using rule 10 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]
  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]


state 35

    (11) expr -> expr POWER expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    PLUS            reduce using rule 11 (expr -> expr POWER expr .)
    MINUS           reduce using rule 11 (expr -> expr POWER expr .)
    TIMES           reduce using rule 11 (expr -> expr POWER expr .)
    DIVIDE          reduce using rule 11 (expr -> expr POWER expr .)
    POWER           reduce using rule 11 (expr -> expr POWER expr .)
    lt              reduce using rule 11 (expr -> expr POWER expr .)
    le              reduce using rule 11 (expr -> expr POWER expr .)
    gt              reduce using rule 11 (expr -> expr POWER expr .)
    ge              reduce using rule 11 (expr -> expr POWER expr .)
    eq              reduce using rule 11 (expr -> expr POWER expr .)
    ne              reduce using rule 11 (expr -> expr POWER expr .)
    $end            reduce using rule 11 (expr -> expr POWER expr .)
    RPAREN          reduce using rule 11 (expr -> expr POWER expr .)

  ! PLUS            [ shift and go to state 18 ]
  ! MINUS           [ shift and go to state 19 ]
  ! TIMES           [ shift and go to state 20 ]
  ! DIVIDE          [ shift and go to state 21 ]
  ! POWER           [ shift and go to state 22 ]


state 36

    (18) relexpr -> expr lt expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 18 (relexpr -> expr lt expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 37

    (19) relexpr -> expr le expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 19 (relexpr -> expr le expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 38

    (20) relexpr -> expr gt expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 20 (relexpr -> expr gt expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 39

    (21) relexpr -> expr ge expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 21 (relexpr -> expr ge expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 40

    (23) relexpr -> expr ne expr .
    (7) expr -> expr . PLUS expr
    (8) expr -> expr . MINUS expr
    (9) expr -> expr . TIMES expr
    (10) expr -> expr . DIVIDE expr
    (11) expr -> expr . POWER expr

    $end            reduce using rule 23 (relexpr -> expr ne expr .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    TIMES           shift and go to state 20
    DIVIDE          shift and go to state 21
    POWER           shift and go to state 22


state 41

    (16) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    POWER           reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    lt              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    le              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    gt              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    ge              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    eq              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    ne              reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 16 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 16 (expr -> LPAREN expr RPAREN .)

