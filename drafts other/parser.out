Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Unused terminals:

    break
    in
    input
    include
    compile
    to
    start
    and
    or
    SEMI
    NEWLINE
    ARGS

Grammar

Rule 0     S' -> program
Rule 1     program -> statement
Rule 2     program -> error
Rule 3     statement -> variable eq expr
Rule 4     statement -> variable eq relexpr
Rule 5     statement -> variable eq
Rule 6     statement -> variable error expr
Rule 7     statement -> variable error relexpr
Rule 8     expr -> expr PLUS expr
Rule 9     expr -> expr MINUS expr
Rule 10    expr -> expr TIMES expr
Rule 11    expr -> expr DIVIDE expr
Rule 12    expr -> expr POWER expr
Rule 13    expr -> INTEGER
Rule 14    expr -> FLOAT
Rule 15    expr -> STRING
Rule 16    expr -> variable
Rule 17    expr -> LPAREN expr RPAREN
Rule 18    expr -> MINUS expr
Rule 19    relexpr -> expr lt expr
Rule 20    relexpr -> expr le expr
Rule 21    relexpr -> expr gt expr
Rule 22    relexpr -> expr ge expr
Rule 23    relexpr -> expr eq expr
Rule 24    relexpr -> expr ne expr
Rule 25    relexpr -> LPAREN relexpr RPAREN
Rule 26    variable -> ID
Rule 27    statement -> print expr
Rule 28    statement -> if expr then
Rule 29    statement -> if relexpr then
Rule 30    statement -> else then
Rule 31    statement -> else if expr then
Rule 32    statement -> else if relexpr then
Rule 33    statement -> repeat until relexpr then
Rule 34    statement -> repeat until expr then
Rule 35    statement -> function variable LPAREN args RPAREN then
Rule 36    statement -> function variable LPAREN RPAREN then
Rule 37    statement -> function error LPAREN args RPAREN then
Rule 38    statement -> function variable error args RPAREN then
Rule 39    statement -> function variable LPAREN args error then
Rule 40    statement -> function variable LPAREN error RPAREN then
Rule 41    statement -> function error LPAREN RPAREN then
Rule 42    statement -> function variable error RPAREN then
Rule 43    statement -> function variable LPAREN error then
Rule 44    statement -> variable LPAREN call_args RPAREN
Rule 45    statement -> variable LPAREN RPAREN
Rule 46    statement -> variable error call_args RPAREN
Rule 47    statement -> variable LPAREN error RPAREN
Rule 48    statement -> variable LPAREN call_args RPAREN statement
Rule 49    statement -> variable LPAREN RPAREN statement
Rule 50    statement -> variable error RPAREN
Rule 51    call_args -> call_args COMMA expr
Rule 52    call_args -> expr
Rule 53    args -> args COMMA variable
Rule 54    args -> variable
Rule 55    statement -> end

Terminals, with rules where they appear

ARGS                 : 
COMMA                : 51 53
DIVIDE               : 11
FLOAT                : 14
ID                   : 26
INTEGER              : 13
LPAREN               : 17 25 35 36 37 39 40 41 43 44 45 47 48 49
MINUS                : 9 18
NEWLINE              : 
PLUS                 : 8
POWER                : 12
RPAREN               : 17 25 35 36 37 38 40 41 42 44 45 46 47 48 49 50
SEMI                 : 
STRING               : 15
TIMES                : 10
and                  : 
break                : 
compile              : 
else                 : 30 31 32
end                  : 55
eq                   : 3 4 5 23
error                : 2 6 7 37 38 39 40 41 42 43 46 47 50
function             : 35 36 37 38 39 40 41 42 43
ge                   : 22
gt                   : 21
if                   : 28 29 31 32
in                   : 
include              : 
input                : 
le                   : 20
lt                   : 19
ne                   : 24
or                   : 
print                : 27
repeat               : 33 34
start                : 
then                 : 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43
to                   : 
until                : 33 34

Nonterminals, with rules where they appear

args                 : 35 37 38 39 53
call_args            : 44 46 48 51
expr                 : 3 6 8 8 9 9 10 10 11 11 12 12 17 18 19 19 20 20 21 21 22 22 23 23 24 24 27 28 31 34 51 52
program              : 0
relexpr              : 4 7 25 29 32 33
statement            : 1 48 49
variable             : 3 4 5 6 7 16 35 36 38 39 40 42 43 44 45 46 47 48 49 50 53 54

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . statement
    (2) program -> . error
    (3) statement -> . variable eq expr
    (4) statement -> . variable eq relexpr
    (5) statement -> . variable eq
    (6) statement -> . variable error expr
    (7) statement -> . variable error relexpr
    (27) statement -> . print expr
    (28) statement -> . if expr then
    (29) statement -> . if relexpr then
    (30) statement -> . else then
    (31) statement -> . else if expr then
    (32) statement -> . else if relexpr then
    (33) statement -> . repeat until relexpr then
    (34) statement -> . repeat until expr then
    (35) statement -> . function variable LPAREN args RPAREN then
    (36) statement -> . function variable LPAREN RPAREN then
    (37) statement -> . function error LPAREN args RPAREN then
    (38) statement -> . function variable error args RPAREN then
    (39) statement -> . function variable LPAREN args error then
    (40) statement -> . function variable LPAREN error RPAREN then
    (41) statement -> . function error LPAREN RPAREN then
    (42) statement -> . function variable error RPAREN then
    (43) statement -> . function variable LPAREN error then
    (44) statement -> . variable LPAREN call_args RPAREN
    (45) statement -> . variable LPAREN RPAREN
    (46) statement -> . variable error call_args RPAREN
    (47) statement -> . variable LPAREN error RPAREN
    (48) statement -> . variable LPAREN call_args RPAREN statement
    (49) statement -> . variable LPAREN RPAREN statement
    (50) statement -> . variable error RPAREN
    (55) statement -> . end
    (26) variable -> . ID

    error           shift and go to state 3
    print           shift and go to state 5
    if              shift and go to state 6
    else            shift and go to state 7
    repeat          shift and go to state 8
    function        shift and go to state 9
    end             shift and go to state 10
    ID              shift and go to state 11

    program                        shift and go to state 1
    statement                      shift and go to state 2
    variable                       shift and go to state 4

state 1

    (0) S' -> program .



state 2

    (1) program -> statement .

    $end            reduce using rule 1 (program -> statement .)


state 3

    (2) program -> error .

    $end            reduce using rule 2 (program -> error .)


state 4

    (3) statement -> variable . eq expr
    (4) statement -> variable . eq relexpr
    (5) statement -> variable . eq
    (6) statement -> variable . error expr
    (7) statement -> variable . error relexpr
    (44) statement -> variable . LPAREN call_args RPAREN
    (45) statement -> variable . LPAREN RPAREN
    (46) statement -> variable . error call_args RPAREN
    (47) statement -> variable . LPAREN error RPAREN
    (48) statement -> variable . LPAREN call_args RPAREN statement
    (49) statement -> variable . LPAREN RPAREN statement
    (50) statement -> variable . error RPAREN

    eq              shift and go to state 12
    error           shift and go to state 13
    LPAREN          shift and go to state 14


state 5

    (27) statement -> print . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 15
    variable                       shift and go to state 20

state 6

    (28) statement -> if . expr then
    (29) statement -> if . relexpr then
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 24
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 22
    relexpr                        shift and go to state 23
    variable                       shift and go to state 20

state 7

    (30) statement -> else . then
    (31) statement -> else . if expr then
    (32) statement -> else . if relexpr then

    then            shift and go to state 25
    if              shift and go to state 26


state 8

    (33) statement -> repeat . until relexpr then
    (34) statement -> repeat . until expr then

    until           shift and go to state 27


state 9

    (35) statement -> function . variable LPAREN args RPAREN then
    (36) statement -> function . variable LPAREN RPAREN then
    (37) statement -> function . error LPAREN args RPAREN then
    (38) statement -> function . variable error args RPAREN then
    (39) statement -> function . variable LPAREN args error then
    (40) statement -> function . variable LPAREN error RPAREN then
    (41) statement -> function . error LPAREN RPAREN then
    (42) statement -> function . variable error RPAREN then
    (43) statement -> function . variable LPAREN error then
    (26) variable -> . ID

    error           shift and go to state 29
    ID              shift and go to state 11

    variable                       shift and go to state 28

state 10

    (55) statement -> end .

    $end            reduce using rule 55 (statement -> end .)


state 11

    (26) variable -> ID .

    eq              reduce using rule 26 (variable -> ID .)
    error           reduce using rule 26 (variable -> ID .)
    LPAREN          reduce using rule 26 (variable -> ID .)
    PLUS            reduce using rule 26 (variable -> ID .)
    MINUS           reduce using rule 26 (variable -> ID .)
    TIMES           reduce using rule 26 (variable -> ID .)
    DIVIDE          reduce using rule 26 (variable -> ID .)
    POWER           reduce using rule 26 (variable -> ID .)
    $end            reduce using rule 26 (variable -> ID .)
    then            reduce using rule 26 (variable -> ID .)
    lt              reduce using rule 26 (variable -> ID .)
    le              reduce using rule 26 (variable -> ID .)
    gt              reduce using rule 26 (variable -> ID .)
    ge              reduce using rule 26 (variable -> ID .)
    ne              reduce using rule 26 (variable -> ID .)
    RPAREN          reduce using rule 26 (variable -> ID .)
    COMMA           reduce using rule 26 (variable -> ID .)


state 12

    (3) statement -> variable eq . expr
    (4) statement -> variable eq . relexpr
    (5) statement -> variable eq .
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (26) variable -> . ID

    $end            reduce using rule 5 (statement -> variable eq .)
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 24
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    variable                       shift and go to state 20
    expr                           shift and go to state 30
    relexpr                        shift and go to state 31

state 13

    (6) statement -> variable error . expr
    (7) statement -> variable error . relexpr
    (46) statement -> variable error . call_args RPAREN
    (50) statement -> variable error . RPAREN
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (51) call_args -> . call_args COMMA expr
    (52) call_args -> . expr
    (26) variable -> . ID

    RPAREN          shift and go to state 35
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 24
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    variable                       shift and go to state 20
    expr                           shift and go to state 32
    relexpr                        shift and go to state 33
    call_args                      shift and go to state 34

state 14

    (44) statement -> variable LPAREN . call_args RPAREN
    (45) statement -> variable LPAREN . RPAREN
    (47) statement -> variable LPAREN . error RPAREN
    (48) statement -> variable LPAREN . call_args RPAREN statement
    (49) statement -> variable LPAREN . RPAREN statement
    (51) call_args -> . call_args COMMA expr
    (52) call_args -> . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    RPAREN          shift and go to state 37
    error           shift and go to state 38
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    variable                       shift and go to state 20
    call_args                      shift and go to state 36
    expr                           shift and go to state 39

state 15

    (27) statement -> print expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    $end            reduce using rule 27 (statement -> print expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 16

    (18) expr -> MINUS . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 45
    variable                       shift and go to state 20

state 17

    (13) expr -> INTEGER .

    PLUS            reduce using rule 13 (expr -> INTEGER .)
    MINUS           reduce using rule 13 (expr -> INTEGER .)
    TIMES           reduce using rule 13 (expr -> INTEGER .)
    DIVIDE          reduce using rule 13 (expr -> INTEGER .)
    POWER           reduce using rule 13 (expr -> INTEGER .)
    $end            reduce using rule 13 (expr -> INTEGER .)
    then            reduce using rule 13 (expr -> INTEGER .)
    lt              reduce using rule 13 (expr -> INTEGER .)
    le              reduce using rule 13 (expr -> INTEGER .)
    gt              reduce using rule 13 (expr -> INTEGER .)
    ge              reduce using rule 13 (expr -> INTEGER .)
    eq              reduce using rule 13 (expr -> INTEGER .)
    ne              reduce using rule 13 (expr -> INTEGER .)
    RPAREN          reduce using rule 13 (expr -> INTEGER .)
    COMMA           reduce using rule 13 (expr -> INTEGER .)


state 18

    (14) expr -> FLOAT .

    PLUS            reduce using rule 14 (expr -> FLOAT .)
    MINUS           reduce using rule 14 (expr -> FLOAT .)
    TIMES           reduce using rule 14 (expr -> FLOAT .)
    DIVIDE          reduce using rule 14 (expr -> FLOAT .)
    POWER           reduce using rule 14 (expr -> FLOAT .)
    $end            reduce using rule 14 (expr -> FLOAT .)
    then            reduce using rule 14 (expr -> FLOAT .)
    lt              reduce using rule 14 (expr -> FLOAT .)
    le              reduce using rule 14 (expr -> FLOAT .)
    gt              reduce using rule 14 (expr -> FLOAT .)
    ge              reduce using rule 14 (expr -> FLOAT .)
    eq              reduce using rule 14 (expr -> FLOAT .)
    ne              reduce using rule 14 (expr -> FLOAT .)
    RPAREN          reduce using rule 14 (expr -> FLOAT .)
    COMMA           reduce using rule 14 (expr -> FLOAT .)


state 19

    (15) expr -> STRING .

    PLUS            reduce using rule 15 (expr -> STRING .)
    MINUS           reduce using rule 15 (expr -> STRING .)
    TIMES           reduce using rule 15 (expr -> STRING .)
    DIVIDE          reduce using rule 15 (expr -> STRING .)
    POWER           reduce using rule 15 (expr -> STRING .)
    $end            reduce using rule 15 (expr -> STRING .)
    then            reduce using rule 15 (expr -> STRING .)
    lt              reduce using rule 15 (expr -> STRING .)
    le              reduce using rule 15 (expr -> STRING .)
    gt              reduce using rule 15 (expr -> STRING .)
    ge              reduce using rule 15 (expr -> STRING .)
    eq              reduce using rule 15 (expr -> STRING .)
    ne              reduce using rule 15 (expr -> STRING .)
    RPAREN          reduce using rule 15 (expr -> STRING .)
    COMMA           reduce using rule 15 (expr -> STRING .)


state 20

    (16) expr -> variable .

    PLUS            reduce using rule 16 (expr -> variable .)
    MINUS           reduce using rule 16 (expr -> variable .)
    TIMES           reduce using rule 16 (expr -> variable .)
    DIVIDE          reduce using rule 16 (expr -> variable .)
    POWER           reduce using rule 16 (expr -> variable .)
    $end            reduce using rule 16 (expr -> variable .)
    then            reduce using rule 16 (expr -> variable .)
    lt              reduce using rule 16 (expr -> variable .)
    le              reduce using rule 16 (expr -> variable .)
    gt              reduce using rule 16 (expr -> variable .)
    ge              reduce using rule 16 (expr -> variable .)
    eq              reduce using rule 16 (expr -> variable .)
    ne              reduce using rule 16 (expr -> variable .)
    RPAREN          reduce using rule 16 (expr -> variable .)
    COMMA           reduce using rule 16 (expr -> variable .)


state 21

    (17) expr -> LPAREN . expr RPAREN
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 46
    variable                       shift and go to state 20

state 22

    (28) statement -> if expr . then
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr

    then            shift and go to state 47
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53


state 23

    (29) statement -> if relexpr . then

    then            shift and go to state 54


state 24

    (17) expr -> LPAREN . expr RPAREN
    (25) relexpr -> LPAREN . relexpr RPAREN
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 24
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 55
    relexpr                        shift and go to state 56
    variable                       shift and go to state 20

state 25

    (30) statement -> else then .

    $end            reduce using rule 30 (statement -> else then .)


state 26

    (31) statement -> else if . expr then
    (32) statement -> else if . relexpr then
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 24
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 57
    relexpr                        shift and go to state 58
    variable                       shift and go to state 20

state 27

    (33) statement -> repeat until . relexpr then
    (34) statement -> repeat until . expr then
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    LPAREN          shift and go to state 61
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    relexpr                        shift and go to state 59
    expr                           shift and go to state 60
    variable                       shift and go to state 20

state 28

    (35) statement -> function variable . LPAREN args RPAREN then
    (36) statement -> function variable . LPAREN RPAREN then
    (38) statement -> function variable . error args RPAREN then
    (39) statement -> function variable . LPAREN args error then
    (40) statement -> function variable . LPAREN error RPAREN then
    (42) statement -> function variable . error RPAREN then
    (43) statement -> function variable . LPAREN error then

    LPAREN          shift and go to state 62
    error           shift and go to state 63


state 29

    (37) statement -> function error . LPAREN args RPAREN then
    (41) statement -> function error . LPAREN RPAREN then

    LPAREN          shift and go to state 64


state 30

    (3) statement -> variable eq expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr

    $end            reduce using rule 3 (statement -> variable eq expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53


state 31

    (4) statement -> variable eq relexpr .

    $end            reduce using rule 4 (statement -> variable eq relexpr .)


state 32

    (6) statement -> variable error expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr
    (52) call_args -> expr .

    $end            reduce using rule 6 (statement -> variable error expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53
    RPAREN          reduce using rule 52 (call_args -> expr .)
    COMMA           reduce using rule 52 (call_args -> expr .)


state 33

    (7) statement -> variable error relexpr .

    $end            reduce using rule 7 (statement -> variable error relexpr .)


state 34

    (46) statement -> variable error call_args . RPAREN
    (51) call_args -> call_args . COMMA expr

    RPAREN          shift and go to state 65
    COMMA           shift and go to state 66


state 35

    (50) statement -> variable error RPAREN .

    $end            reduce using rule 50 (statement -> variable error RPAREN .)


state 36

    (44) statement -> variable LPAREN call_args . RPAREN
    (48) statement -> variable LPAREN call_args . RPAREN statement
    (51) call_args -> call_args . COMMA expr

    RPAREN          shift and go to state 67
    COMMA           shift and go to state 66


state 37

    (45) statement -> variable LPAREN RPAREN .
    (49) statement -> variable LPAREN RPAREN . statement
    (3) statement -> . variable eq expr
    (4) statement -> . variable eq relexpr
    (5) statement -> . variable eq
    (6) statement -> . variable error expr
    (7) statement -> . variable error relexpr
    (27) statement -> . print expr
    (28) statement -> . if expr then
    (29) statement -> . if relexpr then
    (30) statement -> . else then
    (31) statement -> . else if expr then
    (32) statement -> . else if relexpr then
    (33) statement -> . repeat until relexpr then
    (34) statement -> . repeat until expr then
    (35) statement -> . function variable LPAREN args RPAREN then
    (36) statement -> . function variable LPAREN RPAREN then
    (37) statement -> . function error LPAREN args RPAREN then
    (38) statement -> . function variable error args RPAREN then
    (39) statement -> . function variable LPAREN args error then
    (40) statement -> . function variable LPAREN error RPAREN then
    (41) statement -> . function error LPAREN RPAREN then
    (42) statement -> . function variable error RPAREN then
    (43) statement -> . function variable LPAREN error then
    (44) statement -> . variable LPAREN call_args RPAREN
    (45) statement -> . variable LPAREN RPAREN
    (46) statement -> . variable error call_args RPAREN
    (47) statement -> . variable LPAREN error RPAREN
    (48) statement -> . variable LPAREN call_args RPAREN statement
    (49) statement -> . variable LPAREN RPAREN statement
    (50) statement -> . variable error RPAREN
    (55) statement -> . end
    (26) variable -> . ID

    $end            reduce using rule 45 (statement -> variable LPAREN RPAREN .)
    print           shift and go to state 5
    if              shift and go to state 6
    else            shift and go to state 7
    repeat          shift and go to state 8
    function        shift and go to state 9
    end             shift and go to state 10
    ID              shift and go to state 11

    variable                       shift and go to state 4
    statement                      shift and go to state 68

state 38

    (47) statement -> variable LPAREN error . RPAREN

    RPAREN          shift and go to state 69


state 39

    (52) call_args -> expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    RPAREN          reduce using rule 52 (call_args -> expr .)
    COMMA           reduce using rule 52 (call_args -> expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 40

    (8) expr -> expr PLUS . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 70
    variable                       shift and go to state 20

state 41

    (9) expr -> expr MINUS . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 71
    variable                       shift and go to state 20

state 42

    (10) expr -> expr TIMES . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 72
    variable                       shift and go to state 20

state 43

    (11) expr -> expr DIVIDE . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 73
    variable                       shift and go to state 20

state 44

    (12) expr -> expr POWER . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 74
    variable                       shift and go to state 20

state 45

    (18) expr -> MINUS expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 18 (expr -> MINUS expr .)
    MINUS           reduce using rule 18 (expr -> MINUS expr .)
    TIMES           reduce using rule 18 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 18 (expr -> MINUS expr .)
    POWER           reduce using rule 18 (expr -> MINUS expr .)
    $end            reduce using rule 18 (expr -> MINUS expr .)
    then            reduce using rule 18 (expr -> MINUS expr .)
    lt              reduce using rule 18 (expr -> MINUS expr .)
    le              reduce using rule 18 (expr -> MINUS expr .)
    gt              reduce using rule 18 (expr -> MINUS expr .)
    ge              reduce using rule 18 (expr -> MINUS expr .)
    eq              reduce using rule 18 (expr -> MINUS expr .)
    ne              reduce using rule 18 (expr -> MINUS expr .)
    RPAREN          reduce using rule 18 (expr -> MINUS expr .)
    COMMA           reduce using rule 18 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! POWER           [ shift and go to state 44 ]


state 46

    (17) expr -> LPAREN expr . RPAREN
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    RPAREN          shift and go to state 75
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 47

    (28) statement -> if expr then .

    $end            reduce using rule 28 (statement -> if expr then .)


state 48

    (19) relexpr -> expr lt . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 76
    variable                       shift and go to state 20

state 49

    (20) relexpr -> expr le . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 77
    variable                       shift and go to state 20

state 50

    (21) relexpr -> expr gt . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 78
    variable                       shift and go to state 20

state 51

    (22) relexpr -> expr ge . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 79
    variable                       shift and go to state 20

state 52

    (23) relexpr -> expr eq . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 80
    variable                       shift and go to state 20

state 53

    (24) relexpr -> expr ne . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 81
    variable                       shift and go to state 20

state 54

    (29) statement -> if relexpr then .

    $end            reduce using rule 29 (statement -> if relexpr then .)


state 55

    (17) expr -> LPAREN expr . RPAREN
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr

    RPAREN          shift and go to state 75
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53


state 56

    (25) relexpr -> LPAREN relexpr . RPAREN

    RPAREN          shift and go to state 82


state 57

    (31) statement -> else if expr . then
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr

    then            shift and go to state 83
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53


state 58

    (32) statement -> else if relexpr . then

    then            shift and go to state 84


state 59

    (33) statement -> repeat until relexpr . then

    then            shift and go to state 85


state 60

    (34) statement -> repeat until expr . then
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            shift and go to state 86
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 61

    (25) relexpr -> LPAREN . relexpr RPAREN
    (17) expr -> LPAREN . expr RPAREN
    (19) relexpr -> . expr lt expr
    (20) relexpr -> . expr le expr
    (21) relexpr -> . expr gt expr
    (22) relexpr -> . expr ge expr
    (23) relexpr -> . expr eq expr
    (24) relexpr -> . expr ne expr
    (25) relexpr -> . LPAREN relexpr RPAREN
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    LPAREN          shift and go to state 61
    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    relexpr                        shift and go to state 56
    expr                           shift and go to state 87
    variable                       shift and go to state 20

state 62

    (35) statement -> function variable LPAREN . args RPAREN then
    (36) statement -> function variable LPAREN . RPAREN then
    (39) statement -> function variable LPAREN . args error then
    (40) statement -> function variable LPAREN . error RPAREN then
    (43) statement -> function variable LPAREN . error then
    (53) args -> . args COMMA variable
    (54) args -> . variable
    (26) variable -> . ID

    RPAREN          shift and go to state 90
    error           shift and go to state 91
    ID              shift and go to state 11

    variable                       shift and go to state 88
    args                           shift and go to state 89

state 63

    (38) statement -> function variable error . args RPAREN then
    (42) statement -> function variable error . RPAREN then
    (53) args -> . args COMMA variable
    (54) args -> . variable
    (26) variable -> . ID

    RPAREN          shift and go to state 93
    ID              shift and go to state 11

    variable                       shift and go to state 88
    args                           shift and go to state 92

state 64

    (37) statement -> function error LPAREN . args RPAREN then
    (41) statement -> function error LPAREN . RPAREN then
    (53) args -> . args COMMA variable
    (54) args -> . variable
    (26) variable -> . ID

    RPAREN          shift and go to state 95
    ID              shift and go to state 11

    args                           shift and go to state 94
    variable                       shift and go to state 88

state 65

    (46) statement -> variable error call_args RPAREN .

    $end            reduce using rule 46 (statement -> variable error call_args RPAREN .)


state 66

    (51) call_args -> call_args COMMA . expr
    (8) expr -> . expr PLUS expr
    (9) expr -> . expr MINUS expr
    (10) expr -> . expr TIMES expr
    (11) expr -> . expr DIVIDE expr
    (12) expr -> . expr POWER expr
    (13) expr -> . INTEGER
    (14) expr -> . FLOAT
    (15) expr -> . STRING
    (16) expr -> . variable
    (17) expr -> . LPAREN expr RPAREN
    (18) expr -> . MINUS expr
    (26) variable -> . ID

    INTEGER         shift and go to state 17
    FLOAT           shift and go to state 18
    STRING          shift and go to state 19
    LPAREN          shift and go to state 21
    MINUS           shift and go to state 16
    ID              shift and go to state 11

    expr                           shift and go to state 96
    variable                       shift and go to state 20

state 67

    (44) statement -> variable LPAREN call_args RPAREN .
    (48) statement -> variable LPAREN call_args RPAREN . statement
    (3) statement -> . variable eq expr
    (4) statement -> . variable eq relexpr
    (5) statement -> . variable eq
    (6) statement -> . variable error expr
    (7) statement -> . variable error relexpr
    (27) statement -> . print expr
    (28) statement -> . if expr then
    (29) statement -> . if relexpr then
    (30) statement -> . else then
    (31) statement -> . else if expr then
    (32) statement -> . else if relexpr then
    (33) statement -> . repeat until relexpr then
    (34) statement -> . repeat until expr then
    (35) statement -> . function variable LPAREN args RPAREN then
    (36) statement -> . function variable LPAREN RPAREN then
    (37) statement -> . function error LPAREN args RPAREN then
    (38) statement -> . function variable error args RPAREN then
    (39) statement -> . function variable LPAREN args error then
    (40) statement -> . function variable LPAREN error RPAREN then
    (41) statement -> . function error LPAREN RPAREN then
    (42) statement -> . function variable error RPAREN then
    (43) statement -> . function variable LPAREN error then
    (44) statement -> . variable LPAREN call_args RPAREN
    (45) statement -> . variable LPAREN RPAREN
    (46) statement -> . variable error call_args RPAREN
    (47) statement -> . variable LPAREN error RPAREN
    (48) statement -> . variable LPAREN call_args RPAREN statement
    (49) statement -> . variable LPAREN RPAREN statement
    (50) statement -> . variable error RPAREN
    (55) statement -> . end
    (26) variable -> . ID

    $end            reduce using rule 44 (statement -> variable LPAREN call_args RPAREN .)
    print           shift and go to state 5
    if              shift and go to state 6
    else            shift and go to state 7
    repeat          shift and go to state 8
    function        shift and go to state 9
    end             shift and go to state 10
    ID              shift and go to state 11

    variable                       shift and go to state 4
    statement                      shift and go to state 97

state 68

    (49) statement -> variable LPAREN RPAREN statement .

    $end            reduce using rule 49 (statement -> variable LPAREN RPAREN statement .)


state 69

    (47) statement -> variable LPAREN error RPAREN .

    $end            reduce using rule 47 (statement -> variable LPAREN error RPAREN .)


state 70

    (8) expr -> expr PLUS expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 8 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 8 (expr -> expr PLUS expr .)
    $end            reduce using rule 8 (expr -> expr PLUS expr .)
    then            reduce using rule 8 (expr -> expr PLUS expr .)
    lt              reduce using rule 8 (expr -> expr PLUS expr .)
    le              reduce using rule 8 (expr -> expr PLUS expr .)
    gt              reduce using rule 8 (expr -> expr PLUS expr .)
    ge              reduce using rule 8 (expr -> expr PLUS expr .)
    eq              reduce using rule 8 (expr -> expr PLUS expr .)
    ne              reduce using rule 8 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 8 (expr -> expr PLUS expr .)
    COMMA           reduce using rule 8 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44

  ! TIMES           [ reduce using rule 8 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 8 (expr -> expr PLUS expr .) ]
  ! POWER           [ reduce using rule 8 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]


state 71

    (9) expr -> expr MINUS expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 9 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 9 (expr -> expr MINUS expr .)
    $end            reduce using rule 9 (expr -> expr MINUS expr .)
    then            reduce using rule 9 (expr -> expr MINUS expr .)
    lt              reduce using rule 9 (expr -> expr MINUS expr .)
    le              reduce using rule 9 (expr -> expr MINUS expr .)
    gt              reduce using rule 9 (expr -> expr MINUS expr .)
    ge              reduce using rule 9 (expr -> expr MINUS expr .)
    eq              reduce using rule 9 (expr -> expr MINUS expr .)
    ne              reduce using rule 9 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 9 (expr -> expr MINUS expr .)
    COMMA           reduce using rule 9 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44

  ! TIMES           [ reduce using rule 9 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 9 (expr -> expr MINUS expr .) ]
  ! POWER           [ reduce using rule 9 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]


state 72

    (10) expr -> expr TIMES expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 10 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 10 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 10 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 10 (expr -> expr TIMES expr .)
    $end            reduce using rule 10 (expr -> expr TIMES expr .)
    then            reduce using rule 10 (expr -> expr TIMES expr .)
    lt              reduce using rule 10 (expr -> expr TIMES expr .)
    le              reduce using rule 10 (expr -> expr TIMES expr .)
    gt              reduce using rule 10 (expr -> expr TIMES expr .)
    ge              reduce using rule 10 (expr -> expr TIMES expr .)
    eq              reduce using rule 10 (expr -> expr TIMES expr .)
    ne              reduce using rule 10 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 10 (expr -> expr TIMES expr .)
    COMMA           reduce using rule 10 (expr -> expr TIMES expr .)
    POWER           shift and go to state 44

  ! POWER           [ reduce using rule 10 (expr -> expr TIMES expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]


state 73

    (11) expr -> expr DIVIDE expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 11 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 11 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 11 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 11 (expr -> expr DIVIDE expr .)
    $end            reduce using rule 11 (expr -> expr DIVIDE expr .)
    then            reduce using rule 11 (expr -> expr DIVIDE expr .)
    lt              reduce using rule 11 (expr -> expr DIVIDE expr .)
    le              reduce using rule 11 (expr -> expr DIVIDE expr .)
    gt              reduce using rule 11 (expr -> expr DIVIDE expr .)
    ge              reduce using rule 11 (expr -> expr DIVIDE expr .)
    eq              reduce using rule 11 (expr -> expr DIVIDE expr .)
    ne              reduce using rule 11 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 11 (expr -> expr DIVIDE expr .)
    COMMA           reduce using rule 11 (expr -> expr DIVIDE expr .)
    POWER           shift and go to state 44

  ! POWER           [ reduce using rule 11 (expr -> expr DIVIDE expr .) ]
  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]


state 74

    (12) expr -> expr POWER expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    PLUS            reduce using rule 12 (expr -> expr POWER expr .)
    MINUS           reduce using rule 12 (expr -> expr POWER expr .)
    TIMES           reduce using rule 12 (expr -> expr POWER expr .)
    DIVIDE          reduce using rule 12 (expr -> expr POWER expr .)
    POWER           reduce using rule 12 (expr -> expr POWER expr .)
    $end            reduce using rule 12 (expr -> expr POWER expr .)
    then            reduce using rule 12 (expr -> expr POWER expr .)
    lt              reduce using rule 12 (expr -> expr POWER expr .)
    le              reduce using rule 12 (expr -> expr POWER expr .)
    gt              reduce using rule 12 (expr -> expr POWER expr .)
    ge              reduce using rule 12 (expr -> expr POWER expr .)
    eq              reduce using rule 12 (expr -> expr POWER expr .)
    ne              reduce using rule 12 (expr -> expr POWER expr .)
    RPAREN          reduce using rule 12 (expr -> expr POWER expr .)
    COMMA           reduce using rule 12 (expr -> expr POWER expr .)

  ! PLUS            [ shift and go to state 40 ]
  ! MINUS           [ shift and go to state 41 ]
  ! TIMES           [ shift and go to state 42 ]
  ! DIVIDE          [ shift and go to state 43 ]
  ! POWER           [ shift and go to state 44 ]


state 75

    (17) expr -> LPAREN expr RPAREN .

    PLUS            reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    POWER           reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    $end            reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    then            reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    lt              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    le              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    gt              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    ge              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    eq              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    ne              reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 17 (expr -> LPAREN expr RPAREN .)
    COMMA           reduce using rule 17 (expr -> LPAREN expr RPAREN .)


state 76

    (19) relexpr -> expr lt expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 19 (relexpr -> expr lt expr .)
    $end            reduce using rule 19 (relexpr -> expr lt expr .)
    RPAREN          reduce using rule 19 (relexpr -> expr lt expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 77

    (20) relexpr -> expr le expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 20 (relexpr -> expr le expr .)
    $end            reduce using rule 20 (relexpr -> expr le expr .)
    RPAREN          reduce using rule 20 (relexpr -> expr le expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 78

    (21) relexpr -> expr gt expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 21 (relexpr -> expr gt expr .)
    $end            reduce using rule 21 (relexpr -> expr gt expr .)
    RPAREN          reduce using rule 21 (relexpr -> expr gt expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 79

    (22) relexpr -> expr ge expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 22 (relexpr -> expr ge expr .)
    $end            reduce using rule 22 (relexpr -> expr ge expr .)
    RPAREN          reduce using rule 22 (relexpr -> expr ge expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 80

    (23) relexpr -> expr eq expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 23 (relexpr -> expr eq expr .)
    $end            reduce using rule 23 (relexpr -> expr eq expr .)
    RPAREN          reduce using rule 23 (relexpr -> expr eq expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 81

    (24) relexpr -> expr ne expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    then            reduce using rule 24 (relexpr -> expr ne expr .)
    $end            reduce using rule 24 (relexpr -> expr ne expr .)
    RPAREN          reduce using rule 24 (relexpr -> expr ne expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 82

    (25) relexpr -> LPAREN relexpr RPAREN .

    then            reduce using rule 25 (relexpr -> LPAREN relexpr RPAREN .)
    $end            reduce using rule 25 (relexpr -> LPAREN relexpr RPAREN .)
    RPAREN          reduce using rule 25 (relexpr -> LPAREN relexpr RPAREN .)


state 83

    (31) statement -> else if expr then .

    $end            reduce using rule 31 (statement -> else if expr then .)


state 84

    (32) statement -> else if relexpr then .

    $end            reduce using rule 32 (statement -> else if relexpr then .)


state 85

    (33) statement -> repeat until relexpr then .

    $end            reduce using rule 33 (statement -> repeat until relexpr then .)


state 86

    (34) statement -> repeat until expr then .

    $end            reduce using rule 34 (statement -> repeat until expr then .)


state 87

    (17) expr -> LPAREN expr . RPAREN
    (19) relexpr -> expr . lt expr
    (20) relexpr -> expr . le expr
    (21) relexpr -> expr . gt expr
    (22) relexpr -> expr . ge expr
    (23) relexpr -> expr . eq expr
    (24) relexpr -> expr . ne expr
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    RPAREN          shift and go to state 75
    lt              shift and go to state 48
    le              shift and go to state 49
    gt              shift and go to state 50
    ge              shift and go to state 51
    eq              shift and go to state 52
    ne              shift and go to state 53
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 88

    (54) args -> variable .

    RPAREN          reduce using rule 54 (args -> variable .)
    error           reduce using rule 54 (args -> variable .)
    COMMA           reduce using rule 54 (args -> variable .)


state 89

    (35) statement -> function variable LPAREN args . RPAREN then
    (39) statement -> function variable LPAREN args . error then
    (53) args -> args . COMMA variable

    RPAREN          shift and go to state 98
    error           shift and go to state 99
    COMMA           shift and go to state 100


state 90

    (36) statement -> function variable LPAREN RPAREN . then

    then            shift and go to state 101


state 91

    (40) statement -> function variable LPAREN error . RPAREN then
    (43) statement -> function variable LPAREN error . then

    RPAREN          shift and go to state 102
    then            shift and go to state 103


state 92

    (38) statement -> function variable error args . RPAREN then
    (53) args -> args . COMMA variable

    RPAREN          shift and go to state 104
    COMMA           shift and go to state 100


state 93

    (42) statement -> function variable error RPAREN . then

    then            shift and go to state 105


state 94

    (37) statement -> function error LPAREN args . RPAREN then
    (53) args -> args . COMMA variable

    RPAREN          shift and go to state 106
    COMMA           shift and go to state 100


state 95

    (41) statement -> function error LPAREN RPAREN . then

    then            shift and go to state 107


state 96

    (51) call_args -> call_args COMMA expr .
    (8) expr -> expr . PLUS expr
    (9) expr -> expr . MINUS expr
    (10) expr -> expr . TIMES expr
    (11) expr -> expr . DIVIDE expr
    (12) expr -> expr . POWER expr

    RPAREN          reduce using rule 51 (call_args -> call_args COMMA expr .)
    COMMA           reduce using rule 51 (call_args -> call_args COMMA expr .)
    PLUS            shift and go to state 40
    MINUS           shift and go to state 41
    TIMES           shift and go to state 42
    DIVIDE          shift and go to state 43
    POWER           shift and go to state 44


state 97

    (48) statement -> variable LPAREN call_args RPAREN statement .

    $end            reduce using rule 48 (statement -> variable LPAREN call_args RPAREN statement .)


state 98

    (35) statement -> function variable LPAREN args RPAREN . then

    then            shift and go to state 108


state 99

    (39) statement -> function variable LPAREN args error . then

    then            shift and go to state 109


state 100

    (53) args -> args COMMA . variable
    (26) variable -> . ID

    ID              shift and go to state 11

    variable                       shift and go to state 110

state 101

    (36) statement -> function variable LPAREN RPAREN then .

    $end            reduce using rule 36 (statement -> function variable LPAREN RPAREN then .)


state 102

    (40) statement -> function variable LPAREN error RPAREN . then

    then            shift and go to state 111


state 103

    (43) statement -> function variable LPAREN error then .

    $end            reduce using rule 43 (statement -> function variable LPAREN error then .)


state 104

    (38) statement -> function variable error args RPAREN . then

    then            shift and go to state 112


state 105

    (42) statement -> function variable error RPAREN then .

    $end            reduce using rule 42 (statement -> function variable error RPAREN then .)


state 106

    (37) statement -> function error LPAREN args RPAREN . then

    then            shift and go to state 113


state 107

    (41) statement -> function error LPAREN RPAREN then .

    $end            reduce using rule 41 (statement -> function error LPAREN RPAREN then .)


state 108

    (35) statement -> function variable LPAREN args RPAREN then .

    $end            reduce using rule 35 (statement -> function variable LPAREN args RPAREN then .)


state 109

    (39) statement -> function variable LPAREN args error then .

    $end            reduce using rule 39 (statement -> function variable LPAREN args error then .)


state 110

    (53) args -> args COMMA variable .

    RPAREN          reduce using rule 53 (args -> args COMMA variable .)
    error           reduce using rule 53 (args -> args COMMA variable .)
    COMMA           reduce using rule 53 (args -> args COMMA variable .)


state 111

    (40) statement -> function variable LPAREN error RPAREN then .

    $end            reduce using rule 40 (statement -> function variable LPAREN error RPAREN then .)


state 112

    (38) statement -> function variable error args RPAREN then .

    $end            reduce using rule 38 (statement -> function variable error args RPAREN then .)


state 113

    (37) statement -> function error LPAREN args RPAREN then .

    $end            reduce using rule 37 (statement -> function error LPAREN args RPAREN then .)

